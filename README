Project Mewthree

Overview

This project uses a genetic algorithm to evolve an "optimal" Pokémon, code-named "Mewthree." The algorithm can either start from scratch to design a new Pokémon's base stats, types, ability, moveset, and nature, or it can optimize the build (moves, nature, EVs) for an existing Pokémon from Generations 1-4.

The "fitness" of each Pokémon is determined by its performance in simulated battles against a "gauntlet" of strong, predefined opponents. The ultimate goal is to leverage evolutionary computation to discover a competitively viable Pokémon build that can defeat this gauntlet.

How it Works: File Breakdown

The project is divided into several key Python files that work together to run the application.

main.py

High-Level: This is the main entry point of the application. Its sole responsibility is to initialize and launch the tkinter graphical user interface (GUI). It also applies a patch (nest_asyncio) to allow the asyncio event loop (used for battles) to run within the tkinter event loop.

ui.py

High-Level: Defines the entire GUI for the application using tkinter. This is the user's control panel for running experiments. It separates concerns into different tabs.

Key Objects/Functions:

EvolutionApp (class): The main application window.

_create_widgets(): Builds the main UI, including the control panel and the notebook with all the tabs.

build_hyperparameter_tab(): Dynamically creates the "Hyperparameters" tab, allowing the user to edit all settings from config.py.

start_experiment(): Gathers all settings from the UI and launches run_experiment_thread to prevent the UI from freezing.

run_experiment_thread(): The background thread that creates an EvolutionaryAlgorithm instance, runs the evolution, and then calls run_final_tournament.

finish_experiment(): Updates the UI when the thread is done, populating the "Final Champions" list and plotting the graph.

plot_evolution_graph(): Uses matplotlib to render the convergence graph, showing best/average fitness and species count over generations.

ChampionViewerWindow (class): A pop-up window that displays a detailed summary of a single "champion" genome, including its stats, types, moveset, and gauntlet KO count.

TextRedirector (class): A utility class that redirects all console print() statements to a queue, allowing them to be displayed in real-time in the "Experiment Log" tab.

config.py

High-Level: A central configuration file containing all the tunable parameters for the simulation. This file defines the "hyperparameters" for the genetic algorithm as well as the "domain data" for the Pokémon battles.

Key Objects/Functions:

Contains no code, only global constants.

NEAT Parameters: COMPATIBILITY_THRESHOLD, STAGNATION_LIMIT, etc., which control how species are formed and culled.

Evolution Parameters: POPULATION_SIZE, GENERATIONS, MUTATION_RATE, etc.

Pokémon Data Pools: MOVE_POOL, POKEMON_TYPES, NATURES.

Opponent Gauntlets: GAUNTLET (for "Advanced Mode") and SIMPLE_GAUNTLET (for "Simple Mode") define the list of opponents our Pokémon must fight.

pokemon_genome.py

High-Level: Defines the "chromosome" or genetic makeup of a single Pokémon. An object of this class represents one individual in the population and holds all the traits that the genetic algorithm can modify.

Key Objects/Functions:

PokemonGenome (class):

__init__(): Initializes a new genome. It can operate in two modes: "custom" (for "Mewthree"), where stats and types are evolvable, or "standard," where it uses the base stats/types of an existing Pokémon.

_randomize_stats() / _randomize_evs(): Helper functions to create valid, random spreads for stats and EVs that adhere to the limits in config.py.

mutate(): Applies a small, random change to one of the genome's evolvable traits (e.g., swaps a move, changes an EV, adjusts a base stat). This is the primary driver of genetic diversity.

evolutionary_algorithm.py

High-Level: This is the core engine of the project. It implements a genetic algorithm inspired by NEAT (NeuroEvolution of Augmenting Topologies), which uses "speciation" to protect novel solutions and evolve them in parallel.

Key Objects/Functions:

Species (class): A container that groups genetically similar PokemonGenome objects together. This allows, for example, a "fast special attacker" species and a "bulky physical attacker" species to evolve separately without one immediately out-competing the other.

EvolutionaryAlgorithm (class):

run(): The main asynchronous loop that runs for GENERATIONS count. In each generation, it manages the entire evolutionary process:

Calls evaluate_fitness for every genome.

Calls _speciate_population to group genomes.

Calculates shared fitness and culls stagnant or weak species.

Performs _crossover (breeding) and mutate to create the next generation.

_get_compatibility_distance(): A function that compares two genomes to see how "different" they are. This determines if they belong in the same Species.

_crossover(): Takes two parent genomes and "breeds" them to create a child genome, mixing their traits.

battle_evaluator.py

High-Level: This file acts as the "fitness function." Its job is to take a genome, run it through a series of simulated battles using the poke-battle-sim library, and return a score representing its combat performance.

Key Objects/Functions:

evaluate_fitness(): The main fitness function called by the EvolutionaryAlgorithm. It takes a single genome, runs it against the full gauntlet (in "simple" or "advanced" mode) multiple times, and returns a fitness score based on its win rate.

_genome_to_sim_pokemon(): A critical "translator" function. It converts a PokemonGenome object into a pb.Pokemon object that the battle simulator can understand. This function correctly applies the custom stats, types, moves, and ability of the genome to the simulated Pokémon.

get_max_base_power_move(): A "simple" AI logic used in "Simple Mode." It only looks at the available moves and picks the one with the highest base power.

get_best_move_minimax(): A "smart" AI logic used in "Advanced Mode." It uses a minimax algorithm to simulate the next few turns and find the move that leads to the best possible outcome, assuming the opponent also plays optimally.

_evaluate_state(): The helper function for minimax that assigns a "score" to a given battle state (e.g., +100 for a KO, -50 for being poisoned).

run_final_tournament(): This function is called once at the very end of the evolution. It takes the "champion" of each surviving species and pits them against each other in a round-robin tournament to find the one "Ultimate Champion."

generate_data.py

High-Level: A one-time utility script used to populate pokemon_data.py. It connects to the public PokéAPI and downloads the stats, types, abilities, and Gen 4 learnsets for all Pokémon up to #493 (Sinnoh). This script is not run by the main application.

Key Objects/Functions:

generate_pokemon_data(): The main function that fetches all data and writes it to the pokemon_data.py file.

pokemon_data.py

High-Level: A static data file that is the output of generate_data.py. It contains a single, massive dictionary, POKEMON_DATABASE, which maps Pokémon names to their in-game data. This file is used by the UI to populate the "Choose Pokémon" dropdown and by the PokemonGenome class to get the learnset and base stats for non-custom evolutions.

README

High-Level: This file. It provides documentation on the project's goal and structure.

Setup & Running the Project

Install Dependencies: Make sure you have Python installed, then run the following command in your terminal to install the necessary libraries:

pip install -r requirements.txt


Run the Application: Execute the main script from your terminal:

python main.py


Watch the Evolution: The GUI will launch. Choose your Pokémon ("Mewthree" or a standard one), select your mode, and press "Start Evolution." The "Experiment Log" tab will show the live progress, and the "Convergence Graph" tab will update once the experiment is complete.